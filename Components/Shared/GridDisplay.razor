@using LoDCompanion.BackEnd.Models
@using LoDCompanion.BackEnd.Services.Combat
@using LoDCompanion.BackEnd.Services.Dungeon
@using LoDCompanion.BackEnd.Services.Game
@using LoDCompanion.BackEnd.Services.GameData
@using LoDCompanion.BackEnd.Services.Player
@using LoDCompanion.BackEnd.Services.Utilities
@using LoDCompanion.Components.Shared
@implements IDisposable

@inject RoomService RoomService
@inject FloatingTextService FloatingTextService
@inject UserRequestService DiceRollService
@inject FacingDirectionService FacingService
@inject CombatManagerService CombatManager
@inject ActionService ActionService
@inject DungeonState Dungeon
@inject SpellCastingService SpellCastingService
@inject MovementHighlightingService MovementHighlighting


<style>
    .grid-container {
        position: relative;
        border: 2px solid #5a4d3a;
        background-image: url('/images/backgrounds/grass_tile.png');
        /* Example background */
        background-size: 128px 128px;
    }

    .grid-item {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        box-sizing: border-box;
        /* Ensures padding and border are included in the element's total width and height */
        color: white;
        text-shadow: 1px 1px 2px black;
    }

    .walkable-square-highlight {
        background-color: rgba(0, 217, 255, 0.5);
        border: 1px solid rgb(0, 217, 255);
        box-sizing: border-box;
    }

    .furniture-item {
        background-color: rgba(139, 69, 19, 0.5);
        /* Brownish, semi-transparent */
        border: 1px dashed #654321;
    }

    .monster-item,
    .hero-item {
        /* Flexbox helps arrange the name and HP bar vertically */
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        /* Pushes name to top, hp to bottom */
        align-items: center;
        /* Visuals */
        border: 1px solid #1a1a1a;
        box-sizing: border-box;
        color: white;
        text-shadow: 1px 1px 2px black;
        /* Makes text more readable */
        font-weight: bold;
        overflow: hidden;
        /* Ensures content doesn't spill out */
    }

    .monster-item {
        background-color: rgba(178, 34, 34, 0.85);
        /* A semi-transparent red (Firebrick) */
    }

    .hero-item {
        background-color: rgba(46, 139, 87, 0.85);
        /* A semi-transparent green (Seagreen) */
    }

    .corpse-item {
        background-color: rgba(200, 200, 20, 0.65);
        /* A semi-transparent mustard yellow */
    }

    .item-label {
        padding-top: 4px;
        /* Give the name some space from the top edge */
    }

    .hp-bar {
        height: 6px;
        background-color: #dc3545;
        /* Default red for monster HP */
        border-top: 1px solid #1a1a1a;
        align-self: stretch;
        /* Makes the bar span the full width */
    }

    .hero-item .hp-bar {
        background-color: #198754;
        /* Override with green for hero HP */
    }

    .facing-arrow {
        position: absolute;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        /* Adjust size as needed */
        border-right: 6px solid transparent;
        border-bottom: 10px solid rgba(255, 255, 255, 0.8);
        /* A semi-transparent white */
        /* The transition makes the rotation smooth if the facing changes */
        transition: transform 0.3s ease-in-out;
    }

    .turn-announcement-text {
        position: absolute;
        left: 50%;
        top: 45%;
        transform: translate(-50%, -50%);
        /* Center the element perfectly */
        width: 100%;
        /* Ensure it spans the grid for text-align */
        text-align: center;
        font-size: 6vmin;
        /* Responsive font size */
        font-weight: bold;
        color: #ffffff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 10px #000;
        animation: fadeOutAnnouncement 2.5s forwards;
        z-index: 101;
        /* Ensure it's above other grid items */
    }
</style>

<div class="grid-container" style="@GridStyle">
    @if (Room != null)
    {
        @foreach (var square in MovementHighlighting.HighlightedSquares)
        {
            <div class="grid-item walkable-square-highlight" style="@GetSquareStyle(square)"></div>
        }

        @foreach (var text in FloatingTextService.ActiveTexts)
        {
            @if (text.CssClass.Contains("turn-announcement-text"))
            {
                <div class="@text.CssClass">@text.Text</div>
            }
            else
            {
                <div class="floating-text @text.CssClass" style="@GetSquareStyle(text.Position)">
                    @text.Text
                </div>
            }
        }

        @foreach (var furniture in Room.FurnitureList)
        {
            if (furniture.OccupiedSquares != null)
            {
                @foreach (var square in furniture.OccupiedSquares)
                {
                    <ContextMenuTrigger MenuId="universalContextMenu" Data="square" WrapperTag="div" class="grid-background-square"
                        title="@furniture.ToString()" style="@GetSquareStyle(square)">
                    </ContextMenuTrigger>
                }
            }
        }

        @if (Room.MonstersInRoom != null)
        {
            @foreach (var monster in Room.MonstersInRoom)
            {
                <ContextMenuTrigger MenuId="universalContextMenu" Data="monster" WrapperTag="div" class="grid-item monster-item"
                    title="@monster.ToString()" style="@GetItemStyle(monster)"
                    @onclick="() => OnMonsterClicked.InvokeAsync(monster)">
                    <div class="facing-arrow" style="@GetFacingStyle(monster.Facing)"></div>
                    <div class="item-label">@monster.Name</div>
                    <div class="hp-bar" style="width: @(monster.CurrentHP * 100.0 / monster.GetStat(BasicStat.HitPoints))%"></div>
                </ContextMenuTrigger>
            }
        }

        @if (Room.HeroesInRoom != null)
        {
            @foreach (var hero in Room.HeroesInRoom)
            {
                <ContextMenuTrigger MenuId="universalContextMenu" Data="hero" WrapperTag="div" class="grid-item hero-item"
                    title="@hero.ToString()" style="@GetItemStyle(hero)" @onclick="() => OnHeroClicked.InvokeAsync(hero)">
                    <div class="facing-arrow" style="@GetFacingStyle(hero.Facing)"></div>
                    <div class="item-label">@hero.Name</div>
                    <div class="hp-bar" style="width: @(hero.CurrentHP * 100.0 / hero.GetStat(BasicStat.HitPoints))%"></div>
                </ContextMenuTrigger>
            }
        }

        @if (Room.CorpsesInRoom != null)
        {
            @foreach (var corpse in Room.CorpsesInRoom)
            {
                <ContextMenuTrigger MenuId="universalContextMenu" Data="corpse" WrapperTag="div" class="grid-item corpse-item"
                    title="@corpse.ToString()" style="@GetItemStyle(corpse)" @onclick="() => OnCorpseClicked.InvokeAsync(corpse)">
                    <div class="item-label">@corpse.Name</div>
                </ContextMenuTrigger>
            }
        }

        @foreach (var text in FloatingTextService.ActiveTexts)
        {
            <div class="floating-text @text.CssClass" style="@GetSquareStyle(text.Position)">
                @text.Text
            </div>
        }

        @if (DiceRollService.CurrentDiceRequest != null)
        {
            <DiceRollModal />
        }
        @if (FacingService.CurrentDiceRequest != null)
        {
            <FacingSelectionModal />
        }
    }
</div>

@if (SpellCastingService.CurrentDiceRequest != null)
{
    <SpellCastingModal />
}

<ContextMenu Id="universalContextMenu" TItem="object">
    @if (context.Data is GridPosition position)
    {
        var activeHero = CombatManager.ActiveHero;
        @if (activeHero != null && activeHero.CurrentAP >= 1)
        {
            <Item
                OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.Move, Target = position }))">
                Move (@(ActionService.GetActionCost(ActionType.Move)) AP)
            </Item>

            @if (activeHero.ProfessionName == "Wizard" && activeHero.Spells != null)
            {
                <Item>
                    <span>Cast Spell</span>
                    <SubMenu Label="Cast Spell">
                        @foreach (var spell in activeHero.Spells)
                        {
                            @if (spell.TargetType == TargetType.NoTarget)
                            {
                                <Item
                                    OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.CastSpell, Target = position, SecondaryTarget = spell }))">
                                    @spell.Name
                                </Item>
                            }
                        }
                    </SubMenu>
                </Item>
            }
        }
    }
    else if (context.Data is Monster targetMonster)
    {
        var activeHero = CombatManager.ActiveHero;
        @if (activeHero != null && activeHero.Position != null && targetMonster.Position != null)
        {
            @if (GridService.IsAdjacent(activeHero.Position, targetMonster.Position))
            {
                @if (activeHero.Inventory.EquippedWeapon != null && activeHero.Inventory.EquippedWeapon.IsMelee)
                {
                    @if (activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.StandardAttack))
                    {
                        <Item
                            OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.StandardAttack, Target = targetMonster }))">
                            Attack (@(ActionService.GetActionCost(ActionType.StandardAttack)) AP)
                        </Item>
                    }
                    @if (activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.PowerAttack) && activeHero.Inventory.EquippedWeapon != null)
                    {
                        <Item
                            OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.PowerAttack, Target = targetMonster }))">
                            Power Attack (@(ActionService.GetActionCost(ActionType.PowerAttack)) AP)
                        </Item>
                    }
                }

                @if (activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.Shove))
                {
                    <Item
                        OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.Shove, Target = targetMonster }))">
                        Shove (@(ActionService.GetActionCost(ActionType.Shove)) AP)
                    </Item>
                }
            }

            @if (GridService.HasLineOfSight(activeHero.Position, targetMonster.Position, Dungeon.DungeonGrid).CanShoot)
            {
                var distance = GridService.GetDistance(activeHero.Position, targetMonster.Position);
                @if (!GridService.IsAdjacent(activeHero.Position, targetMonster.Position))
                {
                    @if (activeHero.Inventory.EquippedWeapon != null && (activeHero.Inventory.EquippedWeapon.IsRanged ||
                        (activeHero.Inventory.OffHand is Weapon weapon && weapon.IsRanged))
                        && activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.StandardAttack))
                    {
                        <Item
                            OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.StandardAttack, Target = targetMonster }))">
                            Attack (@(ActionService.GetActionCost(ActionType.StandardAttack)) AP)
                        </Item>
                    }

                    @if (activeHero.Inventory.EquippedWeapon != null && activeHero.Inventory.EquippedWeapon.IsMelee
                        && activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.ChargeAttack)
                        && distance <= activeHero.GetStat(BasicStat.Move)
                        && GridService.HasClearPath(activeHero.Position, targetMonster.Position, Dungeon.DungeonGrid))
                    {
                        <Item
                            OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.ChargeAttack, Target = targetMonster }))">
                            Charge Attack (@(ActionService.GetActionCost(ActionType.ChargeAttack)) AP)
                        </Item>
                    }
                }

                if (activeHero.ProfessionName == "Wizard" && activeHero.CurrentAP >= 1
                && activeHero.Spells != null && activeHero.Spells.Any())
                {
                    <Item>
                        <span>Cast Spell</span>
                        <SubMenu Label="Cast Spell">
                            @foreach (var spell in activeHero.Spells)
                            {
                                @if (spell.TargetType == TargetType.SingleTarget || spell.TargetType == TargetType.AreaOfEffect)
                                {
                                    <Item
                                        OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.CastSpell, Target = targetMonster, SecondaryTarget = spell }))">
                                        @spell.Name
                                    </Item>
                                }
                            }
                        </SubMenu>
                    </Item>
                }
            }
        }
    }
    else if (context.Data is Hero targetHero)
    {
        var activeHero = CombatManager.ActiveHero;
        @if (activeHero != null && activeHero == targetHero)
        {
            @if (activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.Parry))
            {
                <Item OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.Parry }))">
                    Parry Stance (Ends Turn)
                </Item>
            }

            @if (activeHero.CurrentEnergy >= 1 && activeHero.Perks != null && activeHero.Perks.Any())
            {
                <Item>
                    <span>Use Perk</span>
                    <SubMenu Label="Use Perk">
                        @foreach (var perk in activeHero.Perks)
                        {
                            <Item OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.UsePerk, Target = activeHero, SecondaryTarget = perk }))">
                                @perk.Name
                            </Item>
                        }
                    </SubMenu>
                </Item>
            }

            @if (activeHero.ProfessionName == "Warrior Priest" && activeHero.CurrentEnergy >= 1
                && activeHero.Prayers != null && activeHero.Prayers.Any())
            {
                <Item>
                    <span>Pray</span>
                    <SubMenu Label="Pray">
                        @foreach (var prayer in activeHero.Prayers)
                        {
                            <Item
                                OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.Pray, Target = activeHero, SecondaryTarget = prayer }))">
                                @prayer.Name
                            </Item>
                        }
                    </SubMenu>
                </Item>
            }

            @if (activeHero.ProfessionName == "Wizard" && activeHero.CurrentAP >= 1
                && activeHero.Spells != null && activeHero.Spells.Any())
            {
                <Item>
                    <span>Cast Spell</span>
                    <SubMenu Label="Cast Spell">
                        @foreach (var spell in activeHero.Spells)
                        {
                            @if (spell.TargetType == TargetType.Self || spell.TargetType == TargetType.Ally)
                            {
                                <Item
                                    OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.CastSpell, Target = activeHero, SecondaryTarget = spell }))">
                                    @spell.Name
                                </Item>
                            }
                        }
                    </SubMenu>
                </Item>
            }

            @if (activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.HealSelf) &&
                activeHero.Inventory.QuickSlots.Any(i => i?.Name.Contains("Bandage") ?? false))
            {
                <Item
                    OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.HealSelf, Target = activeHero }))">
                    Apply Bandage (@(ActionService.GetActionCost(ActionType.HealSelf)) AP)
                </Item>
            }
        }

        if (activeHero != null && activeHero != targetHero) // Can't target self with these actions
        {
            @if (activeHero.CurrentAP >= ActionService.GetActionCost(ActionType.HealOther) &&
                activeHero.Inventory.QuickSlots.Any(i => i?.Name.Contains("Bandage") ?? false))
            {
                <Item
                    OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.HealOther, Target = targetHero }))">
                    Apply Bandage (@(ActionService.GetActionCost(ActionType.HealOther)) AP)
                </Item>
            }

            @if (activeHero.ProfessionName == "Wizard" && activeHero.CurrentAP >= 1
                && activeHero.Spells != null && activeHero.Spells.Any())
            {
                <Item>
                    <span>Cast Spell</span>
                    <SubMenu Label="Cast Spell">
                        @foreach (var spell in activeHero.Spells)
                        {
                            @if (spell.TargetType == TargetType.Ally)
                            {
                                <Item
                                    OnClick="@(() => OnActionClicked.InvokeAsync(new ActionInfo { ActionType = ActionType.CastSpell, Target = targetHero, SecondaryTarget = spell }))">
                                    @spell.Name
                                </Item>
                            }
                        }
                    </SubMenu>
                </Item>
            }
        }
    }
</ContextMenu>

@code {
    [Parameter]
    public FloatingText Text { get; set; } = new();
    [Parameter]
    public Room? Room { get; set; }
    [Parameter]
    public EventCallback<Monster> OnMonsterClicked { get; set; }
    [Parameter]
    public EventCallback<Corpse> OnCorpseClicked { get; set; }
    [Parameter]
    public EventCallback<Hero> OnHeroClicked { get; set; }
    [Parameter]
    public EventCallback<ActionInfo> OnActionClicked { get; set; }


    private Action? _onTextChangedHandler;
    private Action? _onDiceRolledHandler;
    private Action? _onFacingDirectionChangeHandler;
    private Action? _onCastingRequestChangeHandler;

    private string GridStyle
    {
        get
        {
            if (Room == null) return "";
            var style = $"position: relative; width: 90vmin; max-width: 1200px; aspect-ratio: {Room.Width} / {Room.Height};";
            if (!string.IsNullOrEmpty(Room.ImagePath))
            {
                style += $" background-image: url('{Room.ImagePath}'); background-size: 100% 100%; background-position: center;";
            }
            return style;
        }
    }

    private string GetItemStyle(IGameEntity entity)
    {
        // Handle multi-square entities like large monsters or furniture.
        if (entity.OccupiedSquares != null && entity.OccupiedSquares.Any() && entity.Position != null)
        {
            var minWorldX = entity.OccupiedSquares.Min(p => p.X);
            var minWorldY = entity.OccupiedSquares.Min(p => p.Y);
            var worldPosition = new GridPosition(minWorldX, minWorldY, entity.Position.Z);

            var maxWorldX = entity.OccupiedSquares.Max(p => p.X);
            var maxWorldY = entity.OccupiedSquares.Max(p => p.Y);
            var widthInTiles = (maxWorldX - minWorldX) + 1;
            var heightInTiles = (maxWorldY - minWorldY) + 1;

            return GetStyleFromWorldPosition(worldPosition, widthInTiles, heightInTiles);
        }

        // Handle single-square entities.
        if (entity.Position != null)
        {
            return GetStyleFromWorldPosition(entity.Position, 1, 1);
        }

        // If no position data is available, return an empty style.
        return "";
    }

    private string GetSquareStyle(GridPosition position)
    {
        return GetStyleFromWorldPosition(position, 1, 1);
    }

    private string GetStyleFromWorldPosition(GridPosition worldPosition, int widthInTiles, int heightInTiles)
    {
        if (Room == null) return "";

        // Convert world coordinates to local coordinates for rendering.
        var localX = worldPosition.X - Room.GridOffset.X;
        var localY = worldPosition.Y - Room.GridOffset.Y;

        return GetPercentageStyle(localX, localY, widthInTiles, heightInTiles);
    }

    private string GetPercentageStyle(int x, int y, int widthInTiles, int heightInTiles)
    {
        if (Room?.Width is null or 0 || Room?.Height is null or 0)
        {
            return "";
        }

        // Use double for calculations to avoid integer division and ensure precision.
        double roomWidth = Room.Width;
        double roomHeight = Room.Height;

        double left = x / roomWidth * 100;
        double top = y / roomHeight * 100;
        double width = widthInTiles / roomWidth * 100;
        double height = heightInTiles / roomHeight * 100;

        // Use InvariantCulture to ensure '.' is used as the decimal separator in CSS, regardless of server culture.
        FormattableString style = $"position: absolute; left: {left}%; top: {top}%; width: {width}%; height: {height}%;";
        return style.ToString(System.Globalization.CultureInfo.InvariantCulture);
    }

    // You'll need a helper method to position the text
    private string GetItemStyleFromPosition(GridPosition position)
    {
        // This can use your existing GetPercentageStyle logic
        var localX = position.X - (Room?.GridOffset.X ?? 0);
        var localY = position.Y - (Room?.GridOffset.Y ?? 0);
        return GetPercentageStyle(localX, localY, 1, 1);
    }

    private string GetFacingStyle(FacingDirection facing)
    {
        return facing switch
        {
            FacingDirection.North => "transform: rotate(0deg); top: 2px; ",
            FacingDirection.East => "transform: rotate(90deg); right: 2px; top: 40%; ",
            FacingDirection.South => "transform: rotate(180deg); bottom: 2px; ",
            FacingDirection.West => "transform: rotate(270deg); left: 2px; top: 40%; ",
            _ => ""
        };
    }

    protected override void OnInitialized()
    {
        // Store the handler in a field.
        _onTextChangedHandler = () => InvokeAsync(StateHasChanged);
        _onDiceRolledHandler = () => InvokeAsync(StateHasChanged);
        _onFacingDirectionChangeHandler = () => InvokeAsync(StateHasChanged);
        _onCastingRequestChangeHandler = () => InvokeAsync(StateHasChanged);
        // Subscribe using the stored handler.
        FloatingTextService.OnTextChanged += _onTextChangedHandler;
        DiceRollService.OnRollRequested += _onDiceRolledHandler;
        FacingService.OnFacingRequestChanged += _onFacingDirectionChangeHandler;
        SpellCastingService.OnCastingRequestChanged += _onCastingRequestChangeHandler;
    }

    public void Dispose()
    {
        FloatingTextService.OnTextChanged -= _onTextChangedHandler;
        DiceRollService.OnRollRequested -= _onDiceRolledHandler;
        FacingService.OnFacingRequestChanged -= _onFacingDirectionChangeHandler;
        SpellCastingService.OnCastingRequestChanged -= _onCastingRequestChangeHandler;
    }
}