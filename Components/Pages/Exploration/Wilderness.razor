@page "/wilderness"
@rendermode InteractiveServer

@using LoDCompanion.Services.Player
@using LoDCompanion.Services.Dungeon
@using LoDCompanion.Services.Game
@using LoDCompanion.Models.Character
@using LoDCompanion.Components
@using LoDCompanion.Components.Shared

@inject QuestService QuestService
@inject CombatManagerService CombatManager
@inject RoomService RoomService

<div class="wilderness-container" @onclick="CloseContextMenu">
    @if (QuestService.IsQuestActive &&
      QuestService.ActiveQuest?.QuestType == QuestType.WildernessQuest &&
      QuestService.ActiveEncounterRoom != null)
    {
        <div class="quest-header">
            <h1>@QuestService.ActiveQuest.Name</h1>
            <p class="narrative-text"><em>@QuestService.ActiveQuest.NarrativeQuest</em></p>
            @if (!string.IsNullOrEmpty(QuestService.ActiveQuest.SpecialRules))
            {
                <p><strong>Special Rules:</strong> @QuestService.ActiveQuest.SpecialRules</p>
            }
        </div>

        <div class="game-area">
            <GridDisplay Room="QuestService.ActiveEncounterRoom"
                         OnRightClick="ShowContextMenu"
                         OnHeroClicked="HandleHeroClick" />
        </div>

        @if (_isContextMenuVisible && _contextMenuTarget != null)
        {
            <ContextMenu Position="_contextMenuPosition"
                                  TargetName="_contextMenuTargetName"
                                  AvailableActions="_availableActions"
                                  OnActionSelected="ExecuteContextAction" />
        }

        <div class="combat-ui">
            <CombatInterface FeedbackMessage="@_feedbackMessage"
                             OnActionButtonClicked="HandleActionButtonClick" />
        </div>
    }
    else
    {
        <div class="no-quest-active">
            <h3>The wilderness is quiet... for now.</h3>
            <p>Your journey continues uneventfully.</p>
        </div>
    }
</div>

@code {
    private enum InputState
    {
        AwaitingAction,
        SelectingTarget,
        SelectingDestination
    }
    private bool _isContextMenuVisible = false;
    private object? _contextMenuTarget;
    private string _contextMenuTargetName = "";
    private GridPosition? _contextMenuPosition;
    private List<PlayerActionInfo> _availableActions = new();

    private InputState _currentInputState = InputState.AwaitingAction;
    private string _feedbackMessage = string.Empty;

    private void HandleActionButtonClick(PlayerActionType actionType)
    {
        switch (actionType)
        {
            case PlayerActionType.EndTurn:
                CombatManager.HeroPerformsAction(PlayerActionType.EndTurn, null);
                ResetInputState();
                break;
        }
    }

    /// <summary>
    /// Determines which actions are valid for a given target.
    /// </summary>
    private List<PlayerActionInfo> GetAvailableActionsForTarget(object target)
    {
        var actions = new List<PlayerActionInfo>();
        var activeHero = CombatManager.ActiveHero;

        if (activeHero == null) return actions;

        if (target is Monster monster)
        {
            _contextMenuTargetName = monster.Name;
            // You can only attack monsters.
            actions.Add(new PlayerActionInfo { ActionType = PlayerActionType.StandardAttack, ApCost = 1, Target = monster });
            // Add other valid attacks (Power, Charge) based on hero abilities and distance
        }
        else if (target is GridPosition position)
        {
            _contextMenuTargetName = $"Square ({position.X}, {position.Y})";
            // You can only move to empty squares.
            actions.Add(new PlayerActionInfo { ActionType = PlayerActionType.Move, ApCost = 1, Target = position });
        }
        // ... add cases for other target types like doors, other heroes, etc.

        // Filter out actions the hero doesn't have enough AP for.
        return actions.Where(a => activeHero.CurrentAP >= a.ApCost).ToList();
    }

    private void HandleMonsterClick(Monster monster)
    {
        if (_currentInputState == InputState.SelectingTarget)
        {
            CombatManager.HeroPerformsAction(PlayerActionType.StandardAttack, monster);
            ResetInputState();
        }
    }

    private void HandleGridSquareClick(GridPosition position)
    {
        if (_currentInputState == InputState.SelectingDestination)
        {
            CombatManager.HeroPerformsAction(PlayerActionType.Move, position);
            ResetInputState();
        }
    }

    private void ShowContextMenu((object target, MouseEventArgs args) context)
    {
        _contextMenuTarget = context.target;
        _contextMenuPosition = new GridPosition((int)context.args.ClientX, (int)context.args.ClientY, 0);

        // This is the core logic: determine available actions based on the target.
        _availableActions = GetAvailableActionsForTarget(context.target);

        if (_availableActions.Any())
        {
            _isContextMenuVisible = true;
        }
    }

    private void ExecuteContextAction(PlayerActionInfo actionInfo)
    {
        CombatManager.HeroPerformsAction(actionInfo.ActionType, actionInfo.Target);
        CloseContextMenu();
    }

    private void CloseContextMenu()
    {
        _isContextMenuVisible = false;
    }

    private void HandleHeroClick(Hero hero)
    {
        if (CombatManager.IsAwaitingHeroSelection)
        {
            CombatManager.SelectHeroToAction(hero);
        }
    }

    private void ResetInputState()
    {
        _currentInputState = InputState.AwaitingAction;
        _feedbackMessage = string.Empty;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            CombatManager.StartFirstTurn();
        }
    }

    protected override void OnInitialized()
    {
        QuestService.OnQuestStateChanged += () => InvokeAsync(StateHasChanged);
        CombatManager.OnCombatStateChanged += () => InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        QuestService.OnQuestStateChanged -= () => InvokeAsync(StateHasChanged);
        CombatManager.OnCombatStateChanged -= () => InvokeAsync(StateHasChanged);
    }
}